package main

// question:如果一个变量与外层代码块中的变量重名会出现什么状况？

import "fmt"

var block = "package"

func main() {
	// block := "function"
	{
		// block := "inner"
		fmt.Printf("The block is %s.\n", block)
	}
	fmt.Printf("The block is %s.\n", block)
}

// 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。
// 注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
// 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接
// 包含当前代码块的那个代码块开始，一层一层地查找。
// 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错了。

// questionn:不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？
// 为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。注意，在同一个代码块中不允许出现重名
// 的变量，这违背了Go语言的语法。
// 1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了
//    “多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
// 2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
// 3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，
//    它们的类型可以是任意的。
// 4. 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。
//    但是这种现象绝对不会在变量重声明的场景下出现。
